{"version":3,"sources":["../../src/api/accounts.js"],"names":["bcrypt","require","jwt","verifier","config","api","wrap","fn","catch","generateAccessToken","sign","id","account","email","secret","expiresIn","generateRefreshToken","refreshTokenSecret","post","req","res","body","password","password2","status","json","message","success","verify","err","info","Account","findOne","where","hash","create","compare","match","accessToken","refreshToken","cookies","payload","accountId","newAccessToken","accessTokenSecret"],"mappings":"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","file":"accounts.js","sourcesContent":["'use strict';\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst verifier = require('email-verify');\nimport { Account } from '../models';\nimport { Router } from 'express';\n\nexport default ({ config }) => {\n    let api = Router();\n\n    let wrap = fn => (...args) => fn(...args).catch(args[2]);\n\n    // Utility function to generate a JWT\n    const generateAccessToken = account => {\n        return jwt.sign({ id: account.id, email: account.email }, config.secret, {\n            expiresIn: '24h' // token will expire in 24 hours\n        });\n    };\n\n    const generateRefreshToken = (account) => {\n        return jwt.sign({ id: account.id, email: account.email }, config.refreshTokenSecret, {\n            expiresIn: '7d'  // longer expiration for refresh token\n        });\n    };\n\n    api.post('/register', wrap(async (req, res) => {\n        const { email, password, password2 } = req.body;\n\n        if (password !== password2) {\n            res.status(400).json({ message: \"Passwords do not match.\", success: false });\n            return;\n        }\n\n        // Verify the email\n        verifier.verify(email, async (err, info) => {\n            if (err) {\n                res.status(400).json({ message: \"Invalid email.\", success: false });\n                return;\n            }\n        })\n\n        const account = await Account.findOne({ where: { email } });\n        if (account) {\n            res.status(409).json({ message: \"Account already exists.\", success: false });\n            return;\n        }\n        // Hash the password\n        const hash = await bcrypt.hash(password, 10);\n        // Insert the account into the database\n        await Account.create({ email, password: hash });\n        // Generate a token\n        res.json({ message: \"Account created.\", success: true });\n    }));\n\n    api.post('/login', wrap(async (req, res) => {\n        const { email, password } = req.body;\n        // Get the account from the database\n        const account = await Account.findOne({ where: { email } });\n        if (!account) {\n            res.status(404).json({ message: \"Account not found.\", success: false });\n            return;\n        }\n        // Compare the password\n        const match = await bcrypt.compare(password, account.password);\n        if (match) {\n            const accessToken = generateAccessToken(account);\n            const refreshToken = generateRefreshToken(account);\n\n            // Optionally save the refresh token in the database or a secure cache\n            // e.g., await saveRefreshToken(account.id, refreshToken);\n\n            // Send the tokens to the client\n            res.json({\n                accessToken,\n                refreshToken,\n                message: \"Login successful.\", success: true\n            });\n        } else {\n            res.status(401).json({ message: \"Incorrect password.\", success: false });\n        }\n    }));\n\n    api.post('/refresh_token', async (req, res) => {\n        const { refreshToken } = req.cookies;  // Assuming the refresh token is stored in cookies\n        if (!refreshToken) return res.status(401).json({ message: \"No refresh token provided.\", success: false });\n\n        try {\n            const payload = jwt.verify(refreshToken, config.refreshTokenSecret);\n            const accountId = payload.id;  // Extract user ID or other identifiers from the payload\n            // Optionally check against a stored value in the database to ensure the refresh token is still valid\n\n            const newAccessToken = jwt.sign({ id: accountId }, config.accessTokenSecret, { expiresIn: '24h' });\n            res.json({ accessToken: newAccessToken });\n        } catch (err) {\n            return res.status(403).json({ message: \"Invalid refresh token.\", success: false });\n        }\n    });\n\n    return api;\n};\n\n\n"]}